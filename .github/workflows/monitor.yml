import os, json, time
import requests
import pandas as pd
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import google.generativeai as genai  # Updated import

# -----------------------------
# ENV / CONFIG
# -----------------------------
SCOPUS_API_KEY = os.environ.get("SCOPUS_API_KEY", "").strip()
EMAIL_FROM = os.environ.get("EMAIL_FROM", "").strip()
EMAIL_TO = os.environ.get("EMAIL_TO", "").strip()
GMAIL_APP_PASSWORD = os.environ.get("GMAIL_APP_PASSWORD", "").strip()

QUERY_CORE = os.environ.get("SCOPUS_QUERY_CORE", 'TITLE-ABS-KEY("additive manufacturing") AND KEY("superalloys")').strip()
LAB_CONTEXT = os.environ.get("LAB_CONTEXT", "").strip()

GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "").strip()
GEMINI_MODEL_NAME = os.environ.get("GEMINI_MODEL", "gemini-2.0-flash").strip()

# Configure Gemini (Corrected syntax)
if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)

SCOPUS_URL = "https://api.elsevier.com/content/search/scopus"
SCOPUS_HEAD = {"X-ELS-APIKey": SCOPUS_API_KEY, "Accept": "application/json"}

FIELD = (
    "eid,dc:title,dc:creator,prism:coverDate,prism:publicationName,prism:doi,"
    "prism:issn,prism:eIssn,prism:volume,prism:issueIdentifier,prism:pageRange,"
    "subtypeDescription,citedby-count,authkeywords,prism:aggregationType,prism:url,"
    "openaccess,openaccessFlag,afid,affiliation,prism:coverDisplayDate,prism:publicationDate"
)

STATE_FILE = "state.json"
SNAPSHOT_DIR = "snapshots"
KST = ZoneInfo("Asia/Seoul")

# -----------------------------
# State
# -----------------------------
def load_state():
    if not os.path.exists(STATE_FILE):
        return {"notified_eids": [], "last_report_kst": ""}
    try:
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return {"notified_eids": [], "last_report_kst": ""}

def save_state(state):
    # Keep only the last 2000 EIDs to prevent file bloat
    state["notified_eids"] = state["notified_eids"][-2000:]
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f, ensure_ascii=False, indent=2)

# -----------------------------
# Scopus fetch
# -----------------------------
def scopus_search_all(query: str):
    start, count = 0, 25
    rows = []
    total = None

    while True:
        params = {
            "query": query,
            "count": count,
            "start": start,
            "view": "STANDARD",
            "field": FIELD
        }
        r = requests.get(SCOPUS_URL, headers=SCOPUS_HEAD, params=params, timeout=30)
        if r.status_code != 200:
            print(f"‚ö†Ô∏è Scopus API error {r.status_code}")
            break

        data = r.json()
        sr = data.get("search-results", {})
        entries = sr.get("entry", [])

        if total is None:
            total = int(sr.get("opensearch:totalResults", 0))

        if not entries or entries[0].get("error"): # Handle "no results" case
            break

        rows.extend(entries)
        start += count
        if len(rows) >= total or start >= 5000: # Scopus hard limit is usually 5k
            break
        time.sleep(0.2)

    seen = set()
    out = []
    for e in rows:
        eid = e.get("eid")
        if not eid or eid in seen: continue
        seen.add(eid)
        out.append(e)
    return out

# -----------------------------
# Gemini (Corrected Methods)
# -----------------------------
def generate_trend_summary(entries_30d, language="ko"):
    if not GEMINI_API_KEY or not entries_30d:
        return ""

    model = genai.GenerativeModel(GEMINI_MODEL_NAME)
    context = build_metadata_context(entries_30d, cap=60)

    prompt = f"Write a 5-7 sentence trend summary in {'Korean' if language=='ko' else 'English'} based on: {context}"
    
    try:
        resp = model.generate_content(prompt)
        return resp.text.strip()
    except Exception as ex:
        print("‚ö†Ô∏è Gemini trend error:", ex)
        return ""

def generate_research_directions(entries_30d, lab_context, language="ko"):
    if not GEMINI_API_KEY or not entries_30d:
        return ""

    model = genai.GenerativeModel(GEMINI_MODEL_NAME)
    context = build_metadata_context(entries_30d, cap=60)
    
    prompt = f"As a senior researcher, suggest 5 directions for a lab with context: {lab_context}. Use this data: {context}"
    
    try:
        resp = model.generate_content(prompt)
        return resp.text.strip()
    except Exception as ex:
        print("‚ö†Ô∏è Gemini directions error:", ex)
        return ""

# -----------------------------
# Link helpers & Formatting
# -----------------------------
def paper_links(e):
    eid = e.get("eid", "")
    doi = e.get("prism:doi", "")
    doi_link = f"https://doi.org/{doi}" if doi else ""
    scopus_web = f"https://www.scopus.com/record/display.uri?eid={eid}" if eid else ""
    return doi_link, scopus_web

def format_affiliation_one(aff):
    if not aff: return ""
    if isinstance(aff, list) and len(aff) > 0: aff = aff[0]
    if isinstance(aff, dict):
        name = aff.get("affilname", "")
        city = aff.get("affiliation-city", "")
        return f"{name} ({city})" if city else name
    return str(aff)

def build_metadata_context(entries, cap=50):
    lines = []
    for e in entries[:cap]:
        lines.append(f"- Title: {e.get('dc:title')}, Journal: {e.get('prism:publicationName')}")
    return "\n".join(lines)

# -----------------------------
# Email
# -----------------------------
def send_email(subject, html_body):
    to_list = [x.strip() for x in EMAIL_TO.split(",") if x.strip()]
    if not to_list: return

    msg = MIMEMultipart("alternative")
    msg["From"] = EMAIL_FROM
    msg["To"] = ", ".join(to_list)
    msg["Subject"] = subject
    msg.attach(MIMEText(html_body, "html"))

    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(EMAIL_FROM, GMAIL_APP_PASSWORD)
            server.sendmail(EMAIL_FROM, to_list, msg.as_string())
    except Exception as e:
        print(f"‚ùå Email failed: {e}")

def save_snapshot(entries, label):
    if not entries: return
    os.makedirs(SNAPSHOT_DIR, exist_ok=True)
    pd.DataFrame(entries).to_csv(os.path.join(SNAPSHOT_DIR, f"{label}.csv"), index=False)

def build_email_html(entries_30d, cutoff_yyyymmdd, trend_summary, directions_text, new_since_last):
    # Sorting logic
    entries_30d = sorted(entries_30d, key=lambda x: x.get("prism:coverDate", ""), reverse=True)
    
    items = []
    for e in entries_30d[:40]:
        doi_link, scopus_web = paper_links(e)
        items.append(f"<li><b>{e.get('dc:title')}</b><br>{e.get('prism:publicationName')} ({e.get('prism:coverDate')})<br><a href='{scopus_web}'>Scopus Link</a></li>")

    return f"""<html><body>
        <h2>üß≠ Weekly Scopus Monitor</h2>
        <div style='background:#f9f9f9; padding:10px;'>{trend_summary}</div>
        <div style='background:#eef; padding:10px; margin-top:10px;'>{directions_text}</div>
        <hr><ol>{''.join(items)}</ol>
    </body></html>"""

# -----------------------------
# Main
# -----------------------------
def main():
    kst_now = datetime.now(KST)
    cutoff = (kst_now - timedelta(days=30)).strftime("%Y%m%d")
    query = f"({QUERY_CORE}) AND ORIG-LOAD-DATE AFT {cutoff}"

    state = load_state()
    notified = set(state.get("notified_eids", []))

    entries_30d = scopus_search_all(query)
    new_since_last = [e for e in entries_30d if e.get("eid") not in notified]

    save_snapshot(entries_30d, f"report_{kst_now.strftime('%Y%m%d')}")

    trend = generate_trend_summary(entries_30d)
    directions = generate_research_directions(entries_30d, LAB_CONTEXT)

    html = build_email_html(entries_30d, cutoff, trend, directions, new_since_last)
    send_email(f"[Scopus Report] {kst_now.strftime('%Y-%m-%d')}", html)

    # Update state
    for e in entries_30d:
        if e.get("eid"): notified.add(e["eid"])
    state["notified_eids"] = list(notified)
    state["last_report_kst"] = kst_now.isoformat()
    save_state(state)
    print("‚úÖ Process Complete.")

if __name__ == "__main__":
    main()
